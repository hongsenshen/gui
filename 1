import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.dialogs import Messagebox
import tkinter as tk
from tkinter import ttk as tkinter_ttk
from tkinter import Canvas
import os

class QueryClientApp:
    def __init__(self):
        self.root = ttk.Window(themename="flatly")
        self.root.title("信息查询客户端")
        self.root.geometry("400x300")
        self.root.resizable(False, False)
        
        if os.path.exists("custom.png"):
            self.root.iconphoto(True, tk.PhotoImage(file="custom.png"))
        
        self.current_user = None
        self.setup_login_window()
        
    def setup_login_window(self):
        login_frame = ttk.Frame(self.root, padding=20)
        login_frame.pack(expand=True)
        
        ttk.Label(login_frame, text="信息查询系统", font=("Helvetica", 20, "bold")).pack(pady=20)
        ttk.Label(login_frame, text="用户名:").pack(pady=5)
        self.username_entry = ttk.Entry(login_frame)
        self.username_entry.pack(fill=X, pady=5)
        
        ttk.Label(login_frame, text="密码:").pack(pady=5)
        self.password_entry = ttk.Entry(login_frame, show="*")
        self.password_entry.pack(fill=X, pady=5)
        
        ttk.Button(login_frame, text="登录", command=self.login, style="success.TButton").pack(pady=20)
        
    def login(self):
        username = self.username_entry.get()
        password = self.password_entry.get()
        if username and password:
            self.current_user = username
            self.show_main_window()
        else:
            Messagebox.show_error("请输入用户名和密码", "登录失败")
            
    def show_main_window(self):
        for widget in self.root.winfo_children():
            widget.destroy()
            
        self.root.geometry("900x600")
        self.root.resizable(False, False)
        
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.pack(fill=BOTH, expand=True)
        
        user_frame = ttk.Frame(self.main_frame, borderwidth=0)
        user_frame.pack(side=TOP, fill=X, padx=10, pady=(5, 10))
        
        self.user_menu = ttk.Menubutton(user_frame, text=f"欢迎, {self.current_user}")
        self.user_menu.pack(side=RIGHT)
        menu = ttk.Menu(self.user_menu)
        menu.add_command(label="退出登录", command=self.logout)
        self.user_menu.configure(menu=menu)
        
        style = ttk.Style()
        style.configure("Custom.TNotebook", borderwidth=0, background="#f8f9fa")
        style.configure("Custom.TNotebook.Tab", 
                       font=("Helvetica", 12, "bold"), 
                       padding=[15, 8], 
                       background="#e9ecef", 
                       foreground="#212529",
                       borderwidth=0, 
                       relief="flat")
        style.map("Custom.TNotebook.Tab",
                 background=[("selected", "#007bff"), ("active", "#cce5ff")],
                 foreground=[("selected", "white"), ("active", "#212529")],
                 expand=[("selected", 0)],
                 relief=[("selected", "flat")])
        
        self.notebook = ttk.Notebook(self.main_frame, style="Custom.TNotebook")
        self.notebook.pack(fill=X, padx=10, pady=(0, 10))
        
        self.notebook.add(tk.Frame(self.notebook), text="CPU名称查询")
        self.notebook.add(tk.Frame(self.notebook), text="CPU规格参数查询")
        
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        
        self.content_frame = ttk.Frame(self.main_frame, borderwidth=0)
        self.content_frame.pack(fill=BOTH, expand=True, padx=10, pady=0)
        
        self.show_cpu_name_query()
        
    def on_tab_changed(self, event):
        selected_tab = self.notebook.index(self.notebook.select())
        if selected_tab == 0:
            self.show_cpu_name_query()
        elif selected_tab == 1:
            self.show_cpu_spec_query()

    def create_query_page(self, fields, table_headers):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        # 左侧搜索区域
        search_frame = ttk.LabelFrame(self.content_frame, text="搜索条件", padding=15, bootstyle="info")
        search_frame.pack(side=LEFT, fill=Y, padx=5, pady=5, ipadx=10, ipady=10)
        
        row = 0
        self.search_vars = {}
        for field, field_type in fields.items():
            label = ttk.Label(search_frame, text=f"{field}:", width=12, anchor="e")
            label.grid(row=row, column=0, pady=8, padx=(0, 5), sticky="e")
            
            if field_type == "entry":
                var = tk.StringVar()
                entry = ttk.Entry(search_frame, textvariable=var)
                entry.grid(row=row, column=1, pady=8, sticky="ew")
                self.search_vars[field] = var
            elif field_type == "combo":
                var = tk.StringVar()
                combo = ttk.Combobox(search_frame, textvariable=var, 
                                   values=["选项1", "选项2", "选项3"], state="readonly")
                combo.grid(row=row, column=1, pady=8, sticky="ew")
                combo.set("请选择")
                self.search_vars[field] = var
            elif field_type == "radio":
                var = tk.StringVar(value="是")
                frame = ttk.Frame(search_frame)
                frame.grid(row=row, column=1, pady=8, sticky="w")
                for option in ["是", "否"]:
                    ttk.Radiobutton(frame, text=option, value=option, 
                                  variable=var).pack(side=LEFT, padx=5)
                self.search_vars[field] = var
            elif field_type == "check":
                var = tk.BooleanVar()
                ttk.Checkbutton(search_frame, text="启用", variable=var,
                              bootstyle="info-square-toggle").grid(row=row, column=1, pady=8, sticky="w")
                self.search_vars[field] = var
                
            row += 1
            
        ttk.Button(search_frame, text="查询", command=self.perform_search,
                  style="success-outline.TButton", width=15).grid(row=row, column=0, columnspan=2, pady=15)
        
        # 右侧表格区域（初始不显示数据）
        self.table_frame = ttk.LabelFrame(self.content_frame, text="查询结果", padding=15, bootstyle="info")
        self.table_frame.pack(side=RIGHT, fill=BOTH, expand=True, padx=5, pady=5)
        
        self.tree_container = ttk.Frame(self.table_frame)
        self.tree_container.pack(fill=BOTH, expand=True)
        
        style = ttk.Style()
        style.configure("Grid.Treeview", rowheight=30, background="white")
        
        self.tree = tkinter_ttk.Treeview(self.tree_container, style="Grid.Treeview", show="headings")
        self.h_scroll = tk.Scrollbar(self.tree_container, orient="horizontal", command=self.tree.xview)
        self.v_scroll = tk.Scrollbar(self.tree_container, orient="vertical", command=self.tree.yview)
        self.tree.configure(xscrollcommand=self.h_scroll.set, yscrollcommand=self.v_scroll.set)
        
        self.tree.grid(row=0, column=0, sticky="nsew")
        self.v_scroll.grid(row=0, column=1, sticky="ns")
        self.h_scroll.grid(row=1, column=0, sticky="ew")
        self.tree_container.grid_rowconfigure(0, weight=1)
        self.tree_container.grid_columnconfigure(0, weight=1)
        
        self.grid_canvas = Canvas(self.tree_container, highlightthickness=0)
        self.grid_canvas.place(relx=0, rely=0, relwidth=1, relheight=1)
        
        self.tree.bind("<Configure>", self.draw_grid_lines)
        self.tree.bind("<B1-Motion>", self.draw_grid_lines)
        self.tree.bind("<MouseWheel>", self.draw_grid_lines)
        
        self.table_headers = table_headers
        # 不调用 perform_search，等待查询按钮触发
        
    def draw_grid_lines(self, event=None):
        """绘制表格单元格边框并同步滚动"""
        self.grid_canvas.delete("grid")
        
        if not self.tree["columns"]:  # 无数据时不画边框
            return
        
        width = self.tree.winfo_width()
        height = self.tree.winfo_height()
        row_height = 30
        col_width = 100
        
        x_start, x_end = self.tree.xview()
        visible_width = width / (x_end - x_start) if x_end > x_start else width
        offset = x_start * visible_width
        
        for i in range(height // row_height + 1):
            y = i * row_height
            self.grid_canvas.create_line(0, y, width, y, fill="#ced4da", tags="grid")
        
        num_cols = len(self.tree["columns"])
        for i in range(num_cols + 1):
            x = i * col_width - offset
            if 0 <= x <= width:
                self.grid_canvas.create_line(x, 0, x, height, fill="#ced4da", tags="grid")
        
    def perform_search(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
            
        # 示例数据（仅在查询时填充）
        sample_data = [
            ["示例1", "Intel", "4", "3.2GHz", "A", "B", "C", "D"],
            ["示例2", "AMD", "6", "3.8GHz", "E", "F", "G", "H"],
            ["示例3", "Intel", "8", "4.0GHz", "I", "J", "K", "L"]
        ]
        
        if sample_data and len(sample_data) > 0:
            headers = ["属性"] + [f"数据{i+1}" for i in range(len(sample_data))]
            self.tree["columns"] = headers
            for col in headers:
                self.tree.heading(col, text=col)
                self.tree.column(col, width=100, anchor="center")
            
            num_rows = len(self.table_headers)
            num_cols = len(sample_data) + 1
            for row_idx, header in enumerate(self.table_headers):
                values = [header] + [sample_data[col_idx][row_idx] for col_idx in range(len(sample_data))]
                item_id = self.tree.insert("", "end", values=values)
                
                tag = "even" if row_idx % 2 == 0 else "odd"
                self.tree.item(item_id, tags=(tag,))
                
                data_values = values[1:]
                for col_idx, val in enumerate(data_values, 1):
                    if data_values.count(val) < len(data_values):
                        red_tag = f"red_{row_idx}_{col_idx}"
                        self.tree.tag_configure(red_tag, foreground="red")
                        current_tags = self.tree.item(item_id, "tags")
                        self.tree.item(item_id, tags=current_tags + (red_tag,))
        
        else:
            self.tree["columns"] = []
        
        self.tree.tag_configure("even", background="#f0f0f0")
        self.tree.tag_configure("odd", background="#ffffff")
        
        self.draw_grid_lines()
        
    def show_cpu_name_query(self):
        fields = {
            "CPU型号": "entry",
            "制造商": "combo",
            "是否超频": "radio",
            "包含参数": "check"
        }
        headers = ["型号", "制造商", "核心数", "频率", "额外1", "额外2", "额外3", "额外4"]
        self.create_query_page(fields, headers)
        
    def show_cpu_spec_query(self):
        fields = {
            "核心数": "entry",
            "线程数": "entry",
            "制程": "combo",
            "是否支持超线程": "radio"
        }
        headers = ["核心数", "线程数", "缓存", "TDP", "额外1", "额外2", "额外3", "额外4"]
        self.create_query_page(fields, headers)
        
    def logout(self):
        self.current_user = None
        for widget in self.root.winfo_children():
            widget.destroy()
        self.setup_login_window()
        
    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = QueryClientApp()
    app.run()





import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.dialogs import Messagebox
import tkinter as tk
from tkinter import ttk as tkinter_ttk
from tkinter import Canvas
import os

class QueryClientApp:
    def __init__(self):
        self.root = ttk.Window(themename="flatly")
        self.root.title("信息查询客户端")
        self.root.geometry("400x300")
        self.root.resizable(False, False)
        
        if os.path.exists("custom.png"):
            self.root.iconphoto(True, tk.PhotoImage(file="custom.png"))
        
        self.current_user = None
        self.setup_login_window()
        
    def setup_login_window(self):
        login_frame = ttk.Frame(self.root, padding=20)
        login_frame.pack(expand=True)
        
        ttk.Label(login_frame, text="信息查询系统", font=("Helvetica", 20, "bold")).pack(pady=20)
        ttk.Label(login_frame, text="用户名:").pack(pady=5)
        self.username_entry = ttk.Entry(login_frame)
        self.username_entry.pack(fill=X, pady=5)
        
        ttk.Label(login_frame, text="密码:").pack(pady=5)
        self.password_entry = ttk.Entry(login_frame, show="*")
        self.password_entry.pack(fill=X, pady=5)
        
        ttk.Button(login_frame, text="登录", command=self.login, style="success.TButton").pack(pady=20)
        
    def login(self):
        username = self.username_entry.get()
        password = self.password_entry.get()
        if username and password:
            self.current_user = username
            self.show_main_window()
        else:
            Messagebox.show_error("请输入用户名和密码", "登录失败")
            
    def show_main_window(self):
        for widget in self.root.winfo_children():
            widget.destroy()
            
        self.root.geometry("900x600")
        self.root.resizable(False, False)
        
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.pack(fill=BOTH, expand=True)
        
        user_frame = ttk.Frame(self.main_frame, borderwidth=0)
        user_frame.pack(side=TOP, fill=X, padx=10, pady=(5, 10))
        
        self.user_menu = ttk.Menubutton(user_frame, text=f"欢迎, {self.current_user}")
        self.user_menu.pack(side=RIGHT)
        menu = ttk.Menu(self.user_menu)
        menu.add_command(label="退出登录", command=self.logout)
        self.user_menu.configure(menu=menu)
        
        style = ttk.Style()
        style.configure("Custom.TNotebook", borderwidth=0, background="#f8f9fa")
        style.configure("Custom.TNotebook.Tab", 
                       font=("Helvetica", 12, "bold"), 
                       padding=[15, 8], 
                       background="#e9ecef", 
                       foreground="#212529",
                       borderwidth=0, 
                       relief="flat")
        style.map("Custom.TNotebook.Tab",
                 background=[("selected", "#007bff"), ("active", "#cce5ff")],
                 foreground=[("selected", "white"), ("active", "#212529")],
                 expand=[("selected", 0)],
                 relief=[("selected", "flat")])
        
        self.notebook = ttk.Notebook(self.main_frame, style="Custom.TNotebook")
        self.notebook.pack(fill=X, padx=10, pady=(0, 10))
        
        self.notebook.add(tk.Frame(self.notebook), text="CPU名称查询")
        self.notebook.add(tk.Frame(self.notebook), text="CPU规格参数查询")
        
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        
        self.content_frame = ttk.Frame(self.main_frame, borderwidth=0)
        self.content_frame.pack(fill=BOTH, expand=True, padx=10, pady=0)
        
        self.show_cpu_name_query()
        
    def on_tab_changed(self, event):
        selected_tab = self.notebook.index(self.notebook.select())
        if selected_tab == 0:
            self.show_cpu_name_query()
        elif selected_tab == 1:
            self.show_cpu_spec_query()

    def create_query_page(self, fields, table_headers):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        # 左侧搜索区域
        search_frame = ttk.LabelFrame(self.content_frame, text="搜索条件", padding=15, bootstyle="info")
        search_frame.pack(side=LEFT, fill=Y, padx=5, pady=5, ipadx=10, ipady=10)
        
        row = 0
        self.search_vars = {}
        for field, field_type in fields.items():
            label = ttk.Label(search_frame, text=f"{field}:", width=12, anchor="e")
            label.grid(row=row, column=0, pady=8, padx=(0, 5), sticky="e")
            
            if field_type == "entry":
                var = tk.StringVar()
                entry = ttk.Entry(search_frame, textvariable=var)
                entry.grid(row=row, column=1, pady=8, sticky="ew")
                self.search_vars[field] = var
            elif field_type == "combo":
                var = tk.StringVar()
                combo = ttk.Combobox(search_frame, textvariable=var, 
                                   values=["选项1", "选项2", "选项3"], state="readonly")
                combo.grid(row=row, column=1, pady=8, sticky="ew")
                combo.set("请选择")
                self.search_vars[field] = var
            elif field_type == "radio":
                var = tk.StringVar(value="是")
                frame = ttk.Frame(search_frame)
                frame.grid(row=row, column=1, pady=8, sticky="w")
                for option in ["是", "否"]:
                    ttk.Radiobutton(frame, text=option, value=option, 
                                  variable=var).pack(side=LEFT, padx=5)
                self.search_vars[field] = var
            elif field_type == "check":
                var = tk.BooleanVar()
                ttk.Checkbutton(search_frame, text="启用", variable=var,
                              bootstyle="info-square-toggle").grid(row=row, column=1, pady=8, sticky="w")
                self.search_vars[field] = var
                
            row += 1
            
        ttk.Button(search_frame, text="查询", command=self.perform_search,
                  style="success-outline.TButton", width=15).grid(row=row, column=0, columnspan=2, pady=15)
        
        # 右侧表格区域
        table_frame = ttk.LabelFrame(self.content_frame, text="查询结果", padding=15, bootstyle="info")
        table_frame.pack(side=RIGHT, fill=BOTH, expand=True, padx=5, pady=5)
        
        # 使用 Frame 包裹 Treeview、滚动条和 Canvas
        tree_container = ttk.Frame(table_frame)
        tree_container.pack(fill=BOTH, expand=True)
        
        style = ttk.Style()
        style.configure("Grid.Treeview", rowheight=30, background="white")
        
        self.tree = tkinter_ttk.Treeview(tree_container, style="Grid.Treeview", show="headings")
        
        # 添加横向和纵向滚动条
        h_scroll = tk.Scrollbar(tree_container, orient="horizontal", command=self.tree.xview)
        v_scroll = tk.Scrollbar(tree_container, orient="vertical", command=self.tree.yview)
        self.tree.configure(xscrollcommand=h_scroll.set, yscrollcommand=v_scroll.set)
        
        # 布局
        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scroll.grid(row=0, column=1, sticky="ns")
        h_scroll.grid(row=1, column=0, sticky="ew")
        tree_container.grid_rowconfigure(0, weight=1)
        tree_container.grid_columnconfigure(0, weight=1)
        
        # 添加 Canvas 用于绘制单元格边框
        self.grid_canvas = Canvas(tree_container, highlightthickness=0)
        self.grid_canvas.place(relx=0, rely=0, relwidth=1, relheight=1)
        
        self.tree.bind("<Configure>", self.draw_grid_lines)
        self.tree.bind("<B1-Motion>", self.draw_grid_lines)  # 拖动时更新
        self.tree.bind("<MouseWheel>", self.draw_grid_lines)  # 滚轮时更新
        
        self.table_headers = table_headers
        self.perform_search()
        
    def draw_grid_lines(self, event=None):
        """绘制表格单元格边框并同步滚动"""
        self.grid_canvas.delete("grid")
        
        width = self.tree.winfo_width()
        height = self.tree.winfo_height()
        row_height = 30
        col_width = 100
        
        # 获取当前滚动位置
        x_start, x_end = self.tree.xview()
        visible_width = width / (x_end - x_start) if x_end > x_start else width
        offset = x_start * visible_width
        
        # 绘制水平线
        for i in range(height // row_height + 1):
            y = i * row_height
            self.grid_canvas.create_line(0, y, width, y, fill="#ced4da", tags="grid")
        
        # 绘制垂直线（根据所有列）
        num_cols = len(self.tree["columns"])
        for i in range(num_cols + 1):
            x = i * col_width - offset
            if 0 <= x <= width:  # 只绘制可见区域
                self.grid_canvas.create_line(x, 0, x, height, fill="#ced4da", tags="grid")
        
    def perform_search(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
            
        # 示例数据（增加列数以测试滚动条）
        sample_data = [
            ["示例1", "Intel", "4", "3.2GHz", "A", "B", "C", "D"],
            ["示例2", "AMD", "6", "3.8GHz", "E", "F", "G", "H"],
            ["示例3", "Intel", "8", "4.0GHz", "I", "J", "K", "L"]
        ]
        
        if sample_data and len(sample_data) > 0:
            headers = ["属性"] + [f"数据{i+1}" for i in range(len(sample_data))]
            self.tree["columns"] = headers
            for col in headers:
                self.tree.heading(col, text=col)
                self.tree.column(col, width=100, anchor="center")
            
            num_rows = len(self.table_headers)
            num_cols = len(sample_data) + 1
            for row_idx, header in enumerate(self.table_headers):
                values = [header] + [sample_data[col_idx][row_idx] for col_idx in range(len(sample_data))]
                item_id = self.tree.insert("", "end", values=values)
                
                tag = "even" if row_idx % 2 == 0 else "odd"
                self.tree.item(item_id, tags=(tag,))
                
                data_values = values[1:]
                for col_idx, val in enumerate(data_values, 1):
                    if data_values.count(val) < len(data_values):
                        red_tag = f"red_{row_idx}_{col_idx}"
                        self.tree.tag_configure(red_tag, foreground="red")
                        current_tags = self.tree.item(item_id, "tags")
                        self.tree.item(item_id, tags=current_tags + (red_tag,))
        
        else:
            self.tree["columns"] = []
        
        self.tree.tag_configure("even", background="#f0f0f0")
        self.tree.tag_configure("odd", background="#ffffff")
        
        self.draw_grid_lines()
        
    def show_cpu_name_query(self):
        fields = {
            "CPU型号": "entry",
            "制造商": "combo",
            "是否超频": "radio",
            "包含参数": "check"
        }
        headers = ["型号", "制造商", "核心数", "频率", "额外1", "额外2", "额外3", "额外4"]
        self.create_query_page(fields, headers)
        
    def show_cpu_spec_query(self):
        fields = {
            "核心数": "entry",
            "线程数": "entry",
            "制程": "combo",
            "是否支持超线程": "radio"
        }
        headers = ["核心数", "线程数", "缓存", "TDP", "额外1", "额外2", "额外3", "额外4"]
        self.create_query_page(fields, headers)
        
    def logout(self):
        self.current_user = None
        for widget in self.root.winfo_children():
            widget.destroy()
        self.setup_login_window()
        
    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = QueryClientApp()
    app.run()






import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.dialogs import Messagebox
import tkinter as tk
from tkinter import ttk as tkinter_ttk
import os

class QueryClientApp:
    def __init__(self):
        self.root = ttk.Window(themename="flatly")
        self.root.title("信息查询客户端")
        self.root.geometry("400x300")
        self.root.resizable(False, False)
        
        # 设置图标（假设有 custom.png）
        if os.path.exists("custom.png"):
            self.root.iconphoto(True, tk.PhotoImage(file="custom.png"))
        
        self.current_user = None
        self.setup_login_window()
        
    def setup_login_window(self):
        login_frame = ttk.Frame(self.root, padding=20)
        login_frame.pack(expand=True)
        
        ttk.Label(login_frame, text="信息查询系统", font=("Helvetica", 20, "bold")).pack(pady=20)
        ttk.Label(login_frame, text="用户名:").pack(pady=5)
        self.username_entry = ttk.Entry(login_frame)
        self.username_entry.pack(fill=X, pady=5)
        
        ttk.Label(login_frame, text="密码:").pack(pady=5)
        self.password_entry = ttk.Entry(login_frame, show="*")
        self.password_entry.pack(fill=X, pady=5)
        
        ttk.Button(login_frame, text="登录", command=self.login, style="success.TButton").pack(pady=20)
        
    def login(self):
        username = self.username_entry.get()
        password = self.password_entry.get()
        if username and password:
            self.current_user = username
            self.show_main_window()
        else:
            Messagebox.show_error("请输入用户名和密码", "登录失败")
            
    def show_main_window(self):
        for widget in self.root.winfo_children():
            widget.destroy()
            
        self.root.geometry("900x600")
        self.root.resizable(False, False)
        
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.pack(fill=BOTH, expand=True)
        
        user_frame = ttk.Frame(self.main_frame, borderwidth=0)
        user_frame.pack(side=TOP, fill=X, padx=10, pady=(5, 10))
        
        self.user_menu = ttk.Menubutton(user_frame, text=f"欢迎, {self.current_user}")
        self.user_menu.pack(side=RIGHT)
        menu = ttk.Menu(self.user_menu)
        menu.add_command(label="退出登录", command=self.logout)
        self.user_menu.configure(menu=menu)
        
        style = ttk.Style()
        style.configure("Custom.TNotebook", borderwidth=0, background="#f8f9fa")
        style.configure("Custom.TNotebook.Tab", 
                       font=("Helvetica", 12, "bold"), 
                       padding=[15, 8], 
                       background="#e9ecef", 
                       foreground="#212529",
                       borderwidth=0, 
                       relief="flat")
        style.map("Custom.TNotebook.Tab",
                 background=[("selected", "#007bff"), ("active", "#cce5ff")],
                 foreground=[("selected", "white"), ("active", "#212529")],
                 expand=[("selected", 0)],
                 relief=[("selected", "flat")])
        
        self.notebook = ttk.Notebook(self.main_frame, style="Custom.TNotebook")
        self.notebook.pack(fill=X, padx=10, pady=(0, 10))
        
        self.notebook.add(tk.Frame(self.notebook), text="CPU名称查询")
        self.notebook.add(tk.Frame(self.notebook), text="CPU规格参数查询")
        
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        
        self.content_frame = ttk.Frame(self.main_frame, borderwidth=0)
        self.content_frame.pack(fill=BOTH, expand=True, padx=10, pady=0)
        
        self.show_cpu_name_query()
        
    def on_tab_changed(self, event):
        selected_tab = self.notebook.index(self.notebook.select())
        if selected_tab == 0:
            self.show_cpu_name_query()
        elif selected_tab == 1:
            self.show_cpu_spec_query()

    def create_query_page(self, fields, table_headers):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        # 左侧搜索区域
        search_frame = ttk.LabelFrame(self.content_frame, text="搜索条件", padding=15, bootstyle="info")
        search_frame.pack(side=LEFT, fill=Y, padx=5, pady=5, ipadx=10, ipady=10)
        
        row = 0
        self.search_vars = {}
        for field, field_type in fields.items():
            label = ttk.Label(search_frame, text=f"{field}:", width=12, anchor="e")
            label.grid(row=row, column=0, pady=8, padx=(0, 5), sticky="e")
            
            if field_type == "entry":
                var = tk.StringVar()
                entry = ttk.Entry(search_frame, textvariable=var)
                entry.grid(row=row, column=1, pady=8, sticky="ew")
                self.search_vars[field] = var
            elif field_type == "combo":
                var = tk.StringVar()
                combo = ttk.Combobox(search_frame, textvariable=var, 
                                   values=["选项1", "选项2", "选项3"], state="readonly")
                combo.grid(row=row, column=1, pady=8, sticky="ew")
                combo.set("请选择")
                self.search_vars[field] = var
            elif field_type == "radio":
                var = tk.StringVar(value="是")
                frame = ttk.Frame(search_frame)
                frame.grid(row=row, column=1, pady=8, sticky="w")
                for option in ["是", "否"]:
                    ttk.Radiobutton(frame, text=option, value=option, 
                                  variable=var).pack(side=LEFT, padx=5)
                self.search_vars[field] = var
            elif field_type == "check":
                var = tk.BooleanVar()
                ttk.Checkbutton(search_frame, text="启用", variable=var,
                              bootstyle="info-square-toggle").grid(row=row, column=1, pady=8, sticky="w")
                self.search_vars[field] = var
                
            row += 1
            
        ttk.Button(search_frame, text="查询", command=self.perform_search,
                  style="success-outline.TButton", width=15).grid(row=row, column=0, columnspan=2, pady=15)
        
        # 右侧表格区域
        table_frame = ttk.LabelFrame(self.content_frame, text="查询结果", padding=15, bootstyle="info")
        table_frame.pack(side=RIGHT, fill=BOTH, expand=True, padx=5, pady=5)
        
        style = ttk.Style()
        style.configure("Grid.Treeview", 
                       rowheight=30, 
                       borderwidth=1, 
                       relief="solid", 
                       bordercolor="#ced4da",
                       background="white")
        
        self.tree = tkinter_ttk.Treeview(table_frame, style="Grid.Treeview", show="headings")
        self.tree.pack(fill=BOTH, expand=True)
        
        self.table_headers = table_headers
        self.perform_search()
        
    def perform_search(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
            
        sample_data = [
            ["示例1", "Intel", "4", "3.2GHz"],
            ["示例2", "AMD", "6", "3.8GHz"],
            ["示例3", "Intel", "8", "4.0GHz"]
        ]
        
        if sample_data and len(sample_data) > 0:
            # 设置纵向表头
            headers = ["属性"] + [f"数据{i+1}" for i in range(len(sample_data))]
            self.tree["columns"] = headers
            for col in headers:
                self.tree.heading(col, text=col)
                self.tree.column(col, width=100, anchor="center")
            
            # 转置数据并填充
            num_rows = len(self.table_headers)
            num_cols = len(sample_data) + 1  # +1 为标题列
            for row_idx, header in enumerate(self.table_headers):
                values = [header] + [sample_data[col_idx][row_idx] for col_idx in range(len(sample_data))]
                item_id = self.tree.insert("", "end", values=values)
                
                # 设置奇偶行背景色
                tag = "even" if row_idx % 2 == 0 else "odd"
                self.tree.item(item_id, tags=(tag,))
                
                # 高亮不同数据
                data_values = values[1:]  # 排除标题列
                for col_idx, val in enumerate(data_values, 1):
                    if data_values.count(val) < len(data_values):  # 如果值不唯一
                        self.tree.tag_configure(f"red_{row_idx}_{col_idx}", foreground="red")
                        self.tree.item(item_id, tags=(tag, f"red_{row_idx}_{col_idx}"))
        
        else:
            self.tree["columns"] = []
        
        # 设置背景色标签
        self.tree.tag_configure("even", background="#f0f0f0")
        self.tree.tag_configure("odd", background="#ffffff")
        
    def show_cpu_name_query(self):
        fields = {
            "CPU型号": "entry",
            "制造商": "combo",
            "是否超频": "radio",
            "包含参数": "check"
        }
        headers = ["型号", "制造商", "核心数", "频率"]
        self.create_query_page(fields, headers)
        
    def show_cpu_spec_query(self):
        fields = {
            "核心数": "entry",
            "线程数": "entry",
            "制程": "combo",
            "是否支持超线程": "radio"
        }
        headers = ["核心数", "线程数", "缓存", "TDP"]
        self.create_query_page(fields, headers)
        
    def logout(self):
        self.current_user = None
        for widget in self.root.winfo_children():
            widget.destroy()
        self.setup_login_window()
        
    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = QueryClientApp()
    app.run()







import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.dialogs import Messagebox
import tkinter as tk
from tkinter import ttk as tkinter_ttk
import os

class QueryClientApp:
    def __init__(self):
        self.root = ttk.Window(themename="flatly")
        self.root.title("信息查询客户端")
        self.root.geometry("400x300")
        self.root.resizable(False, False)
        
        # 设置图标（假设有 custom.png）
        if os.path.exists("custom.png"):
            self.root.iconphoto(True, tk.PhotoImage(file="custom.png"))
        
        self.current_user = None
        self.setup_login_window()
        
    def setup_login_window(self):
        login_frame = ttk.Frame(self.root, padding=20)
        login_frame.pack(expand=True)
        
        ttk.Label(login_frame, text="信息查询系统", font=("Helvetica", 20, "bold")).pack(pady=20)
        ttk.Label(login_frame, text="用户名:").pack(pady=5)
        self.username_entry = ttk.Entry(login_frame)
        self.username_entry.pack(fill=X, pady=5)
        
        ttk.Label(login_frame, text="密码:").pack(pady=5)
        self.password_entry = ttk.Entry(login_frame, show="*")
        self.password_entry.pack(fill=X, pady=5)
        
        ttk.Button(login_frame, text="登录", command=self.login, style="success.TButton").pack(pady=20)
        
    def login(self):
        username = self.username_entry.get()
        password = self.password_entry.get()
        if username and password:
            self.current_user = username
            self.show_main_window()
        else:
            Messagebox.show_error("请输入用户名和密码", "登录失败")
            
    def show_main_window(self):
        for widget in self.root.winfo_children():
            widget.destroy()
            
        self.root.geometry("900x600")
        self.root.resizable(False, False)
        
        self.main_frame = ttk.Frame(self.root)
        self.main_frame.pack(fill=BOTH, expand=True)
        
        user_frame = ttk.Frame(self.main_frame, borderwidth=0)
        user_frame.pack(side=TOP, fill=X, padx=10, pady=(5, 10))
        
        self.user_menu = ttk.Menubutton(user_frame, text=f"欢迎, {self.current_user}")
        self.user_menu.pack(side=RIGHT)
        menu = ttk.Menu(self.user_menu)
        menu.add_command(label="退出登录", command=self.logout)
        self.user_menu.configure(menu=menu)
        
        style = ttk.Style()
        style.configure("Custom.TNotebook", borderwidth=0, background="#f8f9fa")
        style.configure("Custom.TNotebook.Tab", 
                       font=("Helvetica", 12, "bold"), 
                       padding=[15, 8], 
                       background="#e9ecef", 
                       foreground="#212529",
                       borderwidth=0, 
                       relief="flat")
        style.map("Custom.TNotebook.Tab",
                 background=[("selected", "#007bff"), ("active", "#cce5ff")],
                 foreground=[("selected", "white"), ("active", "#212529")],
                 expand=[("selected", 0)],
                 relief=[("selected", "flat")])
        
        self.notebook = ttk.Notebook(self.main_frame, style="Custom.TNotebook")
        self.notebook.pack(fill=X, padx=10, pady=(0, 10))
        
        self.notebook.add(tk.Frame(self.notebook), text="CPU名称查询")
        self.notebook.add(tk.Frame(self.notebook), text="CPU规格参数查询")
        
        self.notebook.bind("<<NotebookTabChanged>>", self.on_tab_changed)
        
        self.content_frame = ttk.Frame(self.main_frame, borderwidth=0)
        self.content_frame.pack(fill=BOTH, expand=True, padx=10, pady=0)
        
        self.show_cpu_name_query()
        
    def on_tab_changed(self, event):
        selected_tab = self.notebook.index(self.notebook.select())
        if selected_tab == 0:
            self.show_cpu_name_query()
        elif selected_tab == 1:
            self.show_cpu_spec_query()

    def create_query_page(self, fields, table_headers):
        for widget in self.content_frame.winfo_children():
            widget.destroy()
            
        # 左侧搜索区域
        search_frame = ttk.LabelFrame(self.content_frame, text="搜索条件", padding=15, bootstyle="info")
        search_frame.pack(side=LEFT, fill=Y, padx=5, pady=5, ipadx=10, ipady=10)
        
        row = 0
        self.search_vars = {}
        for field, field_type in fields.items():
            label = ttk.Label(search_frame, text=f"{field}:", width=12, anchor="e")
            label.grid(row=row, column=0, pady=8, padx=(0, 5), sticky="e")
            
            if field_type == "entry":
                var = tk.StringVar()
                entry = ttk.Entry(search_frame, textvariable=var)
                entry.grid(row=row, column=1, pady=8, sticky="ew")
                self.search_vars[field] = var
            elif field_type == "combo":
                var = tk.StringVar()
                combo = ttk.Combobox(search_frame, textvariable=var, 
                                   values=["选项1", "选项2", "选项3"], state="readonly")
                combo.grid(row=row, column=1, pady=8, sticky="ew")
                combo.set("请选择")
                self.search_vars[field] = var
            elif field_type == "radio":
                var = tk.StringVar(value="是")
                frame = ttk.Frame(search_frame)
                frame.grid(row=row, column=1, pady=8, sticky="w")
                for option in ["是", "否"]:
                    ttk.Radiobutton(frame, text=option, value=option, 
                                  variable=var).pack(side=LEFT, padx=5)
                self.search_vars[field] = var
            elif field_type == "check":
                var = tk.BooleanVar()
                ttk.Checkbutton(search_frame, text="启用", variable=var,
                              bootstyle="info-square-toggle").grid(row=row, column=1, pady=8, sticky="w")
                self.search_vars[field] = var
                
            row += 1
            
        ttk.Button(search_frame, text="查询", command=self.perform_search,
                  style="success-outline.TButton", width=15).grid(row=row, column=0, columnspan=2, pady=15)
        
        # 右侧表格区域
        table_frame = ttk.LabelFrame(self.content_frame, text="查询结果", padding=15, bootstyle="info")
        table_frame.pack(side=RIGHT, fill=BOTH, expand=True, padx=5, pady=5)
        
        style = ttk.Style()
        style.configure("Grid.Treeview", 
                       rowheight=30, 
                       borderwidth=1, 
                       relief="solid", 
                       bordercolor="#ced4da",
                       background="white")
        
        self.tree = tkinter_ttk.Treeview(table_frame, style="Grid.Treeview", show="headings")
        self.tree.pack(fill=BOTH, expand=True)
        
        self.table_headers = table_headers
        self.perform_search()
        
    def perform_search(self):
        for item in self.tree.get_children():
            self.tree.delete(item)
            
        sample_data = [
            ["示例1", "Intel", "4", "3.2GHz"],
            ["示例2", "AMD", "6", "3.8GHz"],
            ["示例3", "Intel", "8", "4.0GHz"]
        ]
        
        if sample_data and len(sample_data) > 0:
            # 设置纵向表头
            headers = ["属性"] + [f"数据{i+1}" for i in range(len(sample_data))]
            self.tree["columns"] = headers
            for col in headers:
                self.tree.heading(col, text=col)
                self.tree.column(col, width=100, anchor="center")
            
            # 转置数据并填充
            num_rows = len(self.table_headers)
            num_cols = len(sample_data) + 1  # +1 为标题列
            for row_idx, header in enumerate(self.table_headers):
                values = [header] + [sample_data[col_idx][row_idx] for col_idx in range(len(sample_data))]
                item_id = self.tree.insert("", "end", values=values)
                
                # 设置奇偶行背景色
                tag = "even" if row_idx % 2 == 0 else "odd"
                self.tree.item(item_id, tags=(tag,))
                
                # 高亮不同数据
                data_values = values[1:]  # 排除标题列
                for col_idx, val in enumerate(data_values, 1):
                    if data_values.count(val) < len(data_values):  # 如果值不唯一
                        self.tree.tag_configure(f"red_{row_idx}_{col_idx}", foreground="red")
                        self.tree.item(item_id, tags=(tag, f"red_{row_idx}_{col_idx}"))
        
        else:
            self.tree["columns"] = []
        
        # 设置背景色标签
        self.tree.tag_configure("even", background="#f0f0f0")
        self.tree.tag_configure("odd", background="#ffffff")
        
    def show_cpu_name_query(self):
        fields = {
            "CPU型号": "entry",
            "制造商": "combo",
            "是否超频": "radio",
            "包含参数": "check"
        }
        headers = ["型号", "制造商", "核心数", "频率"]
        self.create_query_page(fields, headers)
        
    def show_cpu_spec_query(self):
        fields = {
            "核心数": "entry",
            "线程数": "entry",
            "制程": "combo",
            "是否支持超线程": "radio"
        }
        headers = ["核心数", "线程数", "缓存", "TDP"]
        self.create_query_page(fields, headers)
        
    def logout(self):
        self.current_user = None
        for widget in self.root.winfo_children():
            widget.destroy()
        self.setup_login_window()
        
    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = QueryClientApp()
    app.run()









import sys
import os
from PySide6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
                               QLineEdit, QPushButton, QLabel, QTabWidget, QFrame, QTreeView, 
                               QComboBox, QRadioButton, QCheckBox, QScrollArea, QMessageBox)
from PySide6.QtGui import QStandardItemModel, QStandardItem, QIcon, QColor
from PySide6.QtCore import Qt

class QueryClientApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("信息查询客户端")
        self.setFixedSize(400, 300)
        
        # 设置图标（假设有 custom.png）
        if os.path.exists("custom.png"):
            self.setWindowIcon(QIcon("custom.png"))
        
        self.current_user = None
        self.setup_login_window()
        
    def setup_login_window(self):
        login_widget = QWidget()
        layout = QVBoxLayout()
        
        title = QLabel("信息查询系统")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("font-size: 20px; font-weight: bold;")
        layout.addWidget(title)
        
        layout.addWidget(QLabel("用户名:"))
        self.username_entry = QLineEdit()
        layout.addWidget(self.username_entry)
        
        layout.addWidget(QLabel("密码:"))
        self.password_entry = QLineEdit()
        self.password_entry.setEchoMode(QLineEdit.Password)
        layout.addWidget(self.password_entry)
        
        login_button = QPushButton("登录")
        login_button.clicked.connect(self.login)
        login_button.setStyleSheet("background-color: #28a745; color: white; padding: 5px;")
        layout.addWidget(login_button)
        
        layout.addStretch()
        login_widget.setLayout(layout)
        self.setCentralWidget(login_widget)
        
    def login(self):
        username = self.username_entry.text()
        password = self.password_entry.text()
        if username and password:
            self.current_user = username
            self.show_main_window()
        else:
            QMessageBox.critical(self, "登录失败", "请输入用户名和密码")
            
    def show_main_window(self):
        self.setFixedSize(900, 600)
        
        main_widget = QWidget()
        layout = QVBoxLayout()
        
        # 用户信息
        user_frame = QFrame()
        user_layout = QHBoxLayout()
        user_label = QLabel(f"欢迎, {self.current_user}")
        user_layout.addStretch()
        user_layout.addWidget(user_label)
        user_frame.setLayout(user_layout)
        layout.addWidget(user_frame, alignment=Qt.AlignTop)
        
        # Tab 切换
        self.tabs = QTabWidget()
        self.tabs.addTab(QWidget(), "CPU名称查询")
        self.tabs.addTab(QWidget(), "CPU规格参数查询")
        self.tabs.currentChanged.connect(self.on_tab_changed)
        layout.addWidget(self.tabs)
        
        # 内容区域
        self.content_widget = QWidget()
        self.content_layout = QHBoxLayout()
        self.content_widget.setLayout(self.content_layout)
        layout.addWidget(self.content_widget, stretch=1)
        
        main_widget.setLayout(layout)
        self.setCentralWidget(main_widget)
        
        # 去掉 Tab 下划线并美化
        self.tabs.setStyleSheet("""
            QTabWidget::pane { border: 0px; }
            QTabBar::tab {
                background: #e9ecef;
                color: #212529;
                padding: 8px 15px;
                font: bold 12px;
                border: none;
            }
            QTabBar::tab:selected {
                background: #007bff;
                color: white;
            }
            QTabBar::tab:hover {
                background: #cce5ff;
            }
        """)
        
        self.show_cpu_name_query()
        
    def on_tab_changed(self, index):
        if index == 0:
            self.show_cpu_name_query()
        elif index == 1:
            self.show_cpu_spec_query()

    def create_query_page(self, fields, table_headers):
        for i in reversed(range(self.content_layout.count())):
            self.content_layout.itemAt(i).widget().setParent(None)
        
        # 左侧搜索
        search_frame = QFrame()
        search_frame.setFrameShape(QFrame.Box)
        search_frame.setLineWidth(1)
        search_layout = QVBoxLayout()
        
        for field, field_type in fields.items():
            layout = QHBoxLayout()
            layout.addWidget(QLabel(f"{field}:"))
            if field_type == "entry":
                entry = QLineEdit()
                layout.addWidget(entry)
            elif field_type == "combo":
                combo = QComboBox()
                combo.addItems(["选项1", "选项2", "选项3"])
                layout.addWidget(combo)
            elif field_type == "radio":
                radio_frame = QFrame()
                radio_layout = QHBoxLayout()
                radio_layout.addWidget(QRadioButton("是"))
                radio_layout.addWidget(QRadioButton("否"))
                radio_frame.setLayout(radio_layout)
                layout.addWidget(radio_frame)
            elif field_type == "check":
                check = QCheckBox("启用")
                layout.addWidget(check)
            search_layout.addLayout(layout)
        
        search_button = QPushButton("查询")
        search_button.clicked.connect(self.perform_search)
        search_button.setStyleSheet("background-color: #28a745; color: white; padding: 5px;")
        search_layout.addWidget(search_button)
        search_layout.addStretch()
        search_frame.setLayout(search_layout)
        
        scroll = QScrollArea()
        scroll.setWidget(search_frame)
        scroll.setWidgetResizable(True)
        self.content_layout.addWidget(scroll)
        
        # 右侧表格
        table_frame = QFrame()
        table_frame.setFrameShape(QFrame.Box)
        table_frame.setLineWidth(1)
        table_layout = QVBoxLayout()
        
        self.tree = QTreeView()
        self.tree.setStyleSheet("QTreeView { border: 1px solid #ced4da; } "
                               "QTreeView::item { border: 1px solid #ced4da; height: 30px; }")
        self.model = QStandardItemModel()
        self.tree.setModel(self.model)
        table_layout.addWidget(self.tree)
        
        table_frame.setLayout(table_layout)
        self.content_layout.addWidget(table_frame, stretch=1)
        
        self.table_headers = table_headers
        self.perform_search()
        
    def perform_search(self):
        self.model.clear()
        sample_data = [
            ["示例1", "Intel", "4", "3.2GHz"],
            ["示例2", "AMD", "6", "3.8GHz"],
            ["示例3", "Intel", "8", "4.0GHz"]
        ]
        
        if sample_data and len(sample_data) > 0:
            # 设置纵向表头（第一列为标题）
            headers = ["属性"] + [f"数据{i+1}" for i in range(len(sample_data))]
            self.model.setHorizontalHeaderLabels(headers)
            
            # 转置数据
            num_rows = len(self.table_headers)
            num_cols = len(sample_data) + 1  # +1 为标题列
            for row_idx, header in enumerate(self.table_headers):
                row_items = [QStandardItem(header)]  # 第一列为标题
                for col_idx, data_row in enumerate(sample_data):
                    item = QStandardItem(data_row[row_idx])
                    row_items.append(item)
                self.model.appendRow(row_items)
            
            # 高亮不同数据（同一行对比）
            for row in range(self.model.rowCount()):
                values = [self.model.item(row, col).text() for col in range(1, num_cols)]
                for col in range(1, num_cols):
                    item = self.model.item(row, col)
                    if values.count(item.text()) < len(values):  # 如果值在该行不唯一
                        item.setForeground(QColor("red"))
                
                # 设置奇偶行背景色
                bg_color = "#f0f0f0" if row % 2 == 0 else "#ffffff"
                for col in range(num_cols):
                    self.model.item(row, col).setBackground(QColor(bg_color))
            
            # 设置列宽
            self.tree.setColumnWidth(0, 100)  # 标题列
            for i in range(1, num_cols):
                self.tree.setColumnWidth(i, 100)  # 数据列
        
        else:
            self.model.setHorizontalHeaderLabels([])
        
    def show_cpu_name_query(self):
        fields = {
            "CPU型号": "entry",
            "制造商": "combo",
            "是否超频": "radio",
            "包含参数": "check"
        }
        headers = ["型号", "制造商", "核心数", "频率"]
        self.create_query_page(fields, headers)
        
    def show_cpu_spec_query(self):
        fields = {
            "核心数": "entry",
            "线程数": "entry",
            "制程": "combo",
            "是否支持超线程": "radio"
        }
        headers = ["核心数", "线程数", "缓存", "TDP"]
        self.create_query_page(fields, headers)
        
    def logout(self):
        self.current_user = None
        self.setup_login_window()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = QueryClientApp()
    window.show()
    sys.exit(app.exec())





import sys
import os
from PySide6.QtWidgets import (QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
                               QLineEdit, QPushButton, QLabel, QTabWidget, QFrame, QTreeView, 
                               QComboBox, QRadioButton, QCheckBox, QScrollArea, QMessageBox)
from PySide6.QtGui import QStandardItemModel, QStandardItem, QIcon
from PySide6.QtCore import Qt

class QueryClientApp(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("信息查询客户端")
        self.setFixedSize(400, 300)
        
        # 设置图标（假设有 custom.png）
        if os.path.exists("custom.png"):
            self.setWindowIcon(QIcon("custom.png"))
        
        self.current_user = None
        self.setup_login_window()
        
    def setup_login_window(self):
        login_widget = QWidget()
        layout = QVBoxLayout()
        
        title = QLabel("信息查询系统")
        title.setAlignment(Qt.AlignCenter)
        title.setStyleSheet("font-size: 20px; font-weight: bold;")
        layout.addWidget(title)
        
        layout.addWidget(QLabel("用户名:"))
        self.username_entry = QLineEdit()
        layout.addWidget(self.username_entry)
        
        layout.addWidget(QLabel("密码:"))
        self.password_entry = QLineEdit()
        self.password_entry.setEchoMode(QLineEdit.Password)
        layout.addWidget(self.password_entry)
        
        login_button = QPushButton("登录")
        login_button.clicked.connect(self.login)
        login_button.setStyleSheet("background-color: #28a745; color: white; padding: 5px;")
        layout.addWidget(login_button)
        
        layout.addStretch()
        login_widget.setLayout(layout)
        self.setCentralWidget(login_widget)
        
    def login(self):
        username = self.username_entry.text()
        password = self.password_entry.text()
        if username and password:
            self.current_user = username
            self.show_main_window()
        else:
            QMessageBox.critical(self, "登录失败", "请输入用户名和密码")
            
    def show_main_window(self):
        self.setFixedSize(900, 600)
        
        main_widget = QWidget()
        layout = QVBoxLayout()
        
        # 用户信息
        user_frame = QFrame()
        user_layout = QHBoxLayout()
        user_label = QLabel(f"欢迎, {self.current_user}")
        user_layout.addStretch()
        user_layout.addWidget(user_label)
        user_frame.setLayout(user_layout)
        layout.addWidget(user_frame, alignment=Qt.AlignTop)
        
        # Tab 切换
        self.tabs = QTabWidget()
        self.tabs.addTab(QWidget(), "CPU名称查询")
        self.tabs.addTab(QWidget(), "CPU规格参数查询")
        self.tabs.currentChanged.connect(self.on_tab_changed)
        layout.addWidget(self.tabs)
        
        # 内容区域
        self.content_widget = QWidget()
        self.content_layout = QHBoxLayout()
        self.content_widget.setLayout(self.content_layout)
        layout.addWidget(self.content_widget, stretch=1)
        
        main_widget.setLayout(layout)
        self.setCentralWidget(main_widget)
        
        # 去掉 Tab 下划线并美化
        self.tabs.setStyleSheet("""
            QTabWidget::pane {
                border: 0px;
            }
            QTabBar::tab {
                background: #e9ecef;
                color: #212529;
                padding: 8px 15px;
                font: bold 12px;
                border: none;
            }
            QTabBar::tab:selected {
                background: #007bff;
                color: white;
            }
            QTabBar::tab:hover {
                background: #cce5ff;
            }
        """)
        
        self.show_cpu_name_query()
        
    def on_tab_changed(self, index):
        if index == 0:
            self.show_cpu_name_query()
        elif index == 1:
            self.show_cpu_spec_query()

    def create_query_page(self, fields, table_headers):
        for i in reversed(range(self.content_layout.count())):
            self.content_layout.itemAt(i).widget().setParent(None)
        
        # 左侧搜索
        search_frame = QFrame()
        search_frame.setFrameShape(QFrame.Box)
        search_frame.setLineWidth(1)
        search_layout = QVBoxLayout()
        
        for field, field_type in fields.items():
            layout = QHBoxLayout()
            layout.addWidget(QLabel(f"{field}:"))
            if field_type == "entry":
                entry = QLineEdit()
                layout.addWidget(entry)
            elif field_type == "combo":
                combo = QComboBox()
                combo.addItems(["选项1", "选项2", "选项3"])
                layout.addWidget(combo)
            elif field_type == "radio":
                radio_frame = QFrame()
                radio_layout = QHBoxLayout()
                radio_layout.addWidget(QRadioButton("是"))
                radio_layout.addWidget(QRadioButton("否"))
                radio_frame.setLayout(radio_layout)
                layout.addWidget(radio_frame)
            elif field_type == "check":
                check = QCheckBox("启用")
                layout.addWidget(check)
            search_layout.addLayout(layout)
        
        search_button = QPushButton("查询")
        search_button.clicked.connect(self.perform_search)
        search_button.setStyleSheet("background-color: #28a745; color: white; padding: 5px;")
        search_layout.addWidget(search_button)
        search_layout.addStretch()
        search_frame.setLayout(search_layout)
        
        scroll = QScrollArea()
        scroll.setWidget(search_frame)
        scroll.setWidgetResizable(True)
        self.content_layout.addWidget(scroll)
        
        # 右侧表格
        table_frame = QFrame()
        table_frame.setFrameShape(QFrame.Box)
        table_frame.setLineWidth(1)
        table_layout = QVBoxLayout()
        
        self.tree = QTreeView()
        self.tree.setStyleSheet("QTreeView { border: 1px solid #ced4da; } "
                               "QTreeView::item { border: 1px solid #ced4da; height: 30px; }")
        self.model = QStandardItemModel()
        self.tree.setModel(self.model)
        table_layout.addWidget(self.tree)
        
        table_frame.setLayout(table_layout)
        self.content_layout.addWidget(table_frame, stretch=1)
        
        self.table_headers = table_headers
        self.perform_search()
        
    def perform_search(self):
        self.model.clear()
        sample_data = [
            ["示例1", "Intel", "4", "3.2GHz"],
            ["示例2", "AMD", "6", "3.8GHz"],
            ["示例3", "Intel", "8", "4.0GHz"]
        ]
        
        if sample_data and len(sample_data) > 0:
            self.model.setHorizontalHeaderLabels(self.table_headers[:len(sample_data[0])])
            for row in sample_data:
                items = [QStandardItem(field) for field in row]
                self.model.appendRow(items)
            for i in range(self.model.columnCount()):
                self.tree.setColumnWidth(i, 100)
        else:
            self.model.setHorizontalHeaderLabels([])
        
    def show_cpu_name_query(self):
        fields = {
            "CPU型号": "entry",
            "制造商": "combo",
            "是否超频": "radio",
            "包含参数": "check"
        }
        headers = ["型号", "制造商", "核心数", "频率"]
        self.create_query_page(fields, headers)
        
    def show_cpu_spec_query(self):
        fields = {
            "核心数": "entry",
            "线程数": "entry",
            "制程": "combo",
            "是否支持超线程": "radio"
        }
        headers = ["核心数", "线程数", "缓存", "TDP"]
        self.create_query_page(fields, headers)
        
    def logout(self):
        self.current_user = None
        self.setup_login_window()

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = QueryClientApp()
    window.show()
    sys.exit(app.exec())




def create_query_page(self, fields, table_headers):
    """创建带对比功能的查询页面"""
    for widget in self.content_frame.winfo_children():
        widget.destroy()

    # ======================
    # 左侧搜索和结果区域（保持不变）
    # ======================
    # [原有左侧区域代码保持不变]

    # ======================
    # 右侧对比区域
    # ======================
    # 创建样式
    style = ttk.Style()
    style.configure("Cell.TLabel", borderwidth=1, relief="solid", padding=5, background="white")
    style.configure("Header.TLabel", borderwidth=1, relief="solid", padding=5, 
                   font=("Helvetica", 9, "bold"), background="#f0f0f0")

    compare_container = ttk.Frame(self.content_frame)
    compare_container.pack(side=RIGHT, expand=True, fill=BOTH, padx=5, pady=5)

    # 固定列容器（初始隐藏）
    self.fixed_frame = ttk.Frame(compare_container, width=120)
    self.fixed_headers = table_headers[:3]  # 取前3个字段作为固定列
    
    # 滚动区域容器
    scroll_container = ttk.Frame(compare_container)
    scroll_container.pack(side=LEFT, expand=True, fill=BOTH)

    # 创建画布和滚动条
    self.compare_canvas = tk.Canvas(scroll_container, highlightthickness=0)
    scroll_x = ttk.Scrollbar(scroll_container, orient=HORIZONTAL, command=self.compare_canvas.xview)
    self.compare_canvas.configure(xscrollcommand=scroll_x.set)

    # 内部框架（使用网格布局）
    self.compare_inner_frame = ttk.Frame(self.compare_canvas)
    self.compare_canvas.create_window((0, 0), window=self.compare_inner_frame, anchor="nw")

    # 布局
    scroll_x.pack(side=BOTTOM, fill=X)
    self.compare_canvas.pack(side=TOP, expand=True, fill=BOTH)

    # 初始化网格布局
    for row in range(len(self.fixed_headers)):
        self.compare_inner_frame.grid_rowconfigure(row, weight=1)
        ttk.Label(self.fixed_frame, 
                 text=self.fixed_headers[row],
                 style="Header.TLabel",
                 anchor="center").grid(row=row, column=0, sticky="nsew")

    # 绑定配置事件
    self.compare_inner_frame.bind("<Configure>", 
        lambda e: self.compare_canvas.configure(scrollregion=self.compare_canvas.bbox("all")))

    # 存储对比项
    self.compare_items = []

    # ======================
    # 其他原有代码保持不变
    # ======================
在add_to_compare方法中添加以下逻辑：

def add_to_compare(self, item_data):
    """添加项目到对比列表（表格样式）"""
    # 首次添加时显示固定列
    if not self.compare_items:
        self.fixed_frame.pack(side=LEFT, fill=Y)
    
    # 创建新列
    column_index = len(self.compare_items)
    
    # 添加数据列
    for row, header in enumerate(self.fixed_headers):
        value = item_data.get(header, "N/A")
        lbl = ttk.Label(self.compare_inner_frame,
                       text=value,
                       style="Cell.TLabel",
                       anchor="center")
        lbl.grid(row=row, column=column_index, sticky="nsew")
    
    # 添加操作按钮
    btn_frame = ttk.Frame(self.compare_inner_frame)
    btn_frame.grid(row=len(self.fixed_headers), column=column_index, sticky="nsew")
    
    ttk.Button(btn_frame, 
              text="移除",
              style="danger.TButton",
              command=lambda c=column_index: self.remove_compare_item(c)
              ).pack(pady=5)
    
    # 配置列权重
    self.compare_inner_frame.grid_columnconfigure(column_index, weight=1)
    self.compare_items.append(item_data)

def remove_compare_item(self, column_index):
    """移除指定列的对比项"""
    # 删除对应列的所有组件
    for widget in self.compare_inner_frame.grid_slaves(column=column_index):
        widget.destroy()
    
    # 更新后续列的位置
    for col in range(column_index+1, len(self.compare_items)):
        for widget in self.compare_inner_frame.grid_slaves(column=col):
            widget.grid_configure(column=col-1)
    
    # 删除数据
    del self.compare_items[column_index]
    
    # 如果全部删除则隐藏固定列
    if not self.compare_items:
        self.fixed_frame.pack_forget()
